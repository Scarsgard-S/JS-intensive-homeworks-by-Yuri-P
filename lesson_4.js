/* TASK 1 Какие бывают алгоритмы сортировок?
1. Сортировка быстрая   (Quick Sort – 
                        сложность в среднем O(n*log n), в худшем случае O(n^2)):
    * Разделяет массив на две части относительно опорного элемента.
    * Рекурсивно применяет сортировку к каждой из частей.
    * Один из самых эффективных алгоритмов сортировки при правильной реализации.

2. Сортировка слиянием (Merge Sort – сложность всегда O(n*log n)):
    * Разделяет массив пополам и рекурсивно сортирует каждую половину.
    * Затем объединяет отсортированные половины в один отсортированный массив.
    * Гарантирует стабильность сортировки и обладает хорошей производительностью.

3. Сортировка пузырьком (Bubble Sort –
                        в среднем и худшем случае O(n^2), в лучшем случае O(n)):
    * Проходит по массиву несколько раз, сравнивая соседние элементы и меняя их местами,
    если они находятся в неправильном порядке.
    * Медленный и неэффективный на больших массивах, но легко понимаемый и реализуемый.

4. Сортировка вставками (Insertion Sort –
                        в среднем и худшем случае O(n^2), в лучшем случае O(n)):
    * Проходит по массиву, вставляя каждый элемент на своё место в уже отсортированную часть массива.
    * Эффективен для небольших массивов и массивов, которые уже частично отсортированы.

5. Сортировка выбором (Selection Sort – сложность всегда O(n^2)):
    * Находит минимальный элемент в массиве и перемещает его в начало.
    * Повторяет этот процесс для оставшейся части массива.
    * Неэффективен на больших массивах, но легко понимаем и реализуем.
*/

/* TASK 2 "Операторы и выражения, циклы в JS"
// Определение операторов и выражений

// Операторы - это символы или ключевые слова, которые выполняют операции над операндами (значениями, переменными и т. д.).
// Примеры операторов: + (сложение), - (вычитание), * (умножение), / (деление)

// Выражения - это комбинации значений, переменных и операторов, которые вычисляются в определенное значение.
// Примеры выражений: 2 + 3 (вычисляется в 5), x * y (вычисляется в произведение x и y)

// Пример кода с операторами и выражениями
*/
let x = 5; // Оператор присваивания
let y = 3; 
let sum = x + y; // Здесь оператор + используется для сложения значений x и y, и результат присваивается переменной sum

let a = 10;
let b = 4;
let product = a * b; // Здесь оператор * используется для умножения значений a и b, и результат присваивается переменной product


/** TASK 3 Создать объект Person несколькими способами, после создать объект Person2,
    чтобы в нём были доступны методы объекта Person. Добавить метод logInfo чтоб он был доступен всем объектам

 */

// Создание объекта Person с помощью функции-конструктора (1)
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.logInfo = function() {
      console.log(`Name: ${this.name}, Age: ${this.age}`);
    };
  }
  
  function Person2(name, age) {
    Person.call(this, name, age); // вызов функции-конструктора Person с передачей контекста и аргументов
  }
  
  let person1 = new Person('Alice', 25);
  let person2 = new Person2('Bob', 30);
  
  person1.logInfo(); // Вывод: Name: Alice, Age: 25
  person2.logInfo(); // Вывод: Name: Bob, Age: 30

// Создание объекта Person с помощью литерала объекта (2)
let Person11 = {
    name: 'Alice',
    age: 25,
    logInfo: function() {
      console.log(`Name: ${this.name}, Age: ${this.age}`);
    }
  };
  
  // Создание объекта Person2 с доступом к методам объекта Person
  let Person22 = Object.assign(Object.create(Person11), {
    name: 'Bob',
    age: 30
  });
  
  // Проверка доступа к методам и свойствам
  Person11.logInfo(); // Вывод: Name: Alice, Age: 25
  Person22.logInfo(); // Вывод: Name: Bob, Age: 30
  
  
/* TASK 4 Создать класс PersonThree c get и set для поля name и конструктором, сделать класс наследник от класса Person.

*/

// Создаем класс Person
class Person {
    constructor(name) {
      this._name = name;
    }
  
    get name() {
      return this._name;
    }
  
    set name(newName) {
      this._name = newName;
    }
  }
  
// Создаем класс PersonThree, наследующий от класса Person
class PersonThree extends Person {
    constructor(name, age) {
        super(name);
        this._age = age;
    }
    
    get age() {
        return this._age;
    }
    
    set age(newAge) {
        this._age = newAge;
    }
}

let persona1 = new Person('Alice');
console.log(persona1.name); // Выведет 'Alice'

// Изменяем имя с помощью сеттера
persona1.name = 'Bob';
console.log(persona1.name); // Выведет 'Bob'

let personThree1 = new PersonThree('Charlie', 30);
console.log(personThree1.name); // Выведет 'Charlie'
console.log(personThree1.age); // Выведет 30

// Изменяем возраст с помощью сеттера
personThree1.age = 35;
console.log(personThree1.age); // Выведет 35

  

/* BONUS 1 Написать функцию, которая вернет массив с первой парой чисел, сумма которых равна total:

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
total = 13;
//result = [4, 9]

const firstSum = (arr, total) => {
      //Решение
}

firstSum(arr,total)
*/

const firstSum = (arr, total) => {
    // Создаем пустой объект, который будет хранить пары чисел и их индексы
    const numMap = {};

    // Проходим по массиву
    for (let i = 0; i < arr.length; i++) {
        // Рассчитываем разницу между total и текущим числом
        const difference = total - arr[i];

        // Проверяем, есть ли такая разница в объекте numMap
        if (numMap[difference] !== undefined) {
            // Если да, возвращаем массив с найденной парой чисел и их индексами
            return [arr[numMap[difference]], arr[i]];
        }

        // Если такой разницы нет, сохраняем текущее число и его индекс в объект numMap
        numMap[arr[i]] = i;
    }

    // Если не найдено подходящих пар чисел, возвращаем пустой массив
    return [];
}

const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const total = 4;
console.log(firstSum(arr, total)); 

/* BONUS 2
"Сложность алгоритма Поиска суммы с использованием словаря – O(n), 
потому что мы проходим по массиву только один раз и 
выполняем операции добавления и поиска в объекте numMap за постоянное время O(1)."
*/