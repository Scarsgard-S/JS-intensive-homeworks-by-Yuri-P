/* 1) Подробно прочитать про метод запроса OPTIONS - и кратко его описать, когда вызывается, где используется, что передает и принимает.
    Метод OPTIONS - это стандартный HTTP-метод, который используется для получения информации о возможностях сервера или параметрах конкретного ресурса.
    - Обычно вызывается клиентом до отправки основного запроса на сервер.
    - OPTIONS широко используется в ситуациях, когда клиент хочет узнать, какие методы поддерживает сервер (например, GET, POST, PUT, DELETE), или проверить доступность и возможности сервера.
    - Серверы также могут использовать OPTIONS для предоставления информации о разрешенных методах и заголовках для определенного ресурса.
    - Запрос OPTIONS не передает никаких данных или параметров. Он может содержать заголовки, такие как Host (доменное имя и порт), Origin (источник запроса) и Access-Control-Request-Method (метод, который клиент собирается использовать в последующем запросе).
    - В ответ на запрос OPTIONS, сервер возвращает информацию о поддерживаемых методах, заголовках и других возможностях для данного ресурса. Параметр ответа Access-Control-Allow-Methods указывает, какие методы доступны для использования клиенту.
*/


/* 2) Прочитать и описать ключевые особенности "HTTP" Версии 3.0

1. Протокол передачи данных QUIC (Quick UDP Internet Connections):
    - HTTP/3 использует протокол передачи данных QUIC, который основан на UDP (User Datagram Protocol), что снижает задержки установления соединения. В отличие от TCP, которому требуется несколько обменов пакетами для установления
2. Улучшенная безопасность с помощью протокола TLS (Transport Layer Security):
    - HTTP/3 включает в себя шифрование данных по умолчанию, используя протокол TLS (Transport Layer Security).
    - Протокол TLS обеспечивает шифрование данных между клиентом и сервером, что обеспечивает конфиденциальность и целостность передаваемой информации.
3. Мультиплексирование:
    - HTTP/3 поддерживает мультиплексирование, что позволяет одновременную передачу нескольких запросов и ответов на одном соединении.
    - Это уменьшает задержки, связанные с установлением новых соединений для каждого запроса, и позволяет эффективно использовать доступную пропускную способность.
4. Механизм восстановления от потерь пакетов:
    - QUIC включает в себя встроенные механизмы обнаружения и восстановления от потерь пакетов.
    - Благодаря механизму обнаружения потерь пакетов и быстрой переотправке, QUIC позволяет более эффективно восстанавливаться от потерь данных, минимизируя задержки и повторные запросы.
*/


/* 3) a. Прочитать про способы отмены запроса, включая объект "AbortController" 

Существует множество способов отмены запроса, вот некоторые из них:
1. Использование объекта AbortController: Создание экземпляра AbortController и передача его сигнала в опцию `signal` при выполнении запроса. Затем можно вызвать метод `abort()` на контроллере для отмены запроса.
2. Использование флага или переменной для контроля состояния: Создание флага или переменной, которая изменяется для прерывания выполнения запроса. Затем проверяется значение флага в обработчиках ответа и ошибки.
3. Использование функции `abort()` для прерывания XHR-запроса: Создание объекта XMLHttpRequest (XHR), открытие запроса и установка обработчиков событий. После этого можно вызвать метод `abort()` на объекте XMLHttpRequest для отмены запроса.
4. Использование сторонних библиотек или фреймворков: Некоторые библиотеки или фреймворки предоставляют собственные механизмы для отмены запросов, такие как Axios с объектом CancelController или jQuery с функцией `abort()`.
*/


// 3) b. Написать по 2 примера создания примитивных значений (если есть несколько способов - использовать) (string, number, boolean, null, undefined, symbol, bigInt

// string
let myString = "Hello World"; // Двойные кавычки
let singleQuteString = 'Brave New World'; // Одинарные кавычкиsdaf
let anotherString = new String("This is a string");// Использование конструктора Stringj
let numberInString = 14;
let differentString = `This is a number ${numberInString}`; // Обратные кавычки поддерживают вычисляемые выражения, переменные и переносы строк
let implicitСonversionString = 2 + ''; // '2'
// number
let myNumber = 42;
let anotherNumber = 1 + 3; // Использование математических операций
let stringToNumber = +'1'; // Преобразование в number унарным +, а также арифметическими операциями, побитовыми операторами
// bigInt
let myBigInt = 12345678901234567890n;
let anotherBigInt = BigInt("98765432109876543210");
// boolean
let myBoolean = true; // или false
let anotherBoolean = 10 > 5; // Использование логических операторов
let doubleNon = !!0 // false
// null, undefined
let myNull = null;// Значение null указывает на отсутствие значения или объекта
let myUndefined;// Значение undefined указывает на неинициализированное значение или отсутствие значения переменной, в данном случае переменная уже имеет тип undefined
// symbol
let mySymbol = Symbol();
let anotherSymbol = Symbol("description");


/* 4) Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем **ReferenceError**?

При обращении к переменным, созданным с использованием `let` или `const`, до их объявления возникает ошибка `ReferenceError`. Это происходит из-за особенностей фазы исполнения кода в JavaScript, называемой "всплытие" (hoisting). Переменные, объявленные с помощью `let` и `const`, не инициализируются до фактического места их объявления, поэтому они не доступны до этого момента. Чтобы избежать ошибок, рекомендуется всегда объявлять переменные перед их использованием.
*/


// 5) Решить:

const res = "B" + "a" + (1 - "hello");
console.log(res);// Выведет "NaN"
// Пояснение: В данном примере, строка "hello" не может быть преобразована в число, поэтому результатом выражения (1 - "hello") будет NaN. Затем, оператор + будет использован для конкатенации строк "B", "a" и NaN, и результатом будет строка "BaNaN".
const res2 = (true && 3) + "d";

console.log(res2);// Выведет "3d"
// Пояснение: В этом случае, выражение (true && 3) возвращает последнее истинное значение, которым является число 3. Затем оператор + используется для конкатенации числа 3 и строки "d", и результатом будет строка "3d".

const res3 = Boolean(true && 3) + "d";
console.log(res3); // Выведет "trued"
// Пояснение: В данном примере, выражение (true && 3) возвращает значение 3, так как оба операнда истинны. Затем, функция Boolean() вызывается на числовом значении 3, которое является истинным, возвращая логическое значение true. Затем, оператор + используется для конкатенации логического значения true (которое будет преобразовано в строку "true") и строки "d", и результатом будет строка "trued".
